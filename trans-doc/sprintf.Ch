PRINTF(3) Linux 程序员手册 PRINTF(3)

名称
       printf、fprintf、dprintf、sprintf、snprintf、vprintf、vfprintf、vdprintf、vprintf、vsnprintf - 格式化输出转换
       转换

语法
       #include <stdio.h>

       int printf(const char *format, ...)；
       int fprintf(FILE *stream, const char *format, ...)；
       int dprintf(int fd, const char *format, ...)；
       int sprintf(char *str, const char *format, ...)；
       int snprintf(char *str, size_t size, const char *format, ...)；

       #include <stdarg.h>

       int vprintf(const char *format, va_list ap)；
       int vfprintf(FILE *stream, const char *format, va_list ap)；
       int vdprintf(int fd, const char *format, va_list ap)；
       int vsprintf(char *str, const char *format, va_list ap)；
       int vsnprintf(char *str, size_t size, const char *format, va_list ap)；

   glibc 的功能测试宏要求（参见 feature_test_macros(7)）：

       snprintf()、vsnprintf()：
           _xopen_source >= 500 || _isoc99_source ||
               | /* Glibc 版本 <= 2.19: */ _BSD_SOURCE

       dprintf()、vdprintf()：
           自 glibc 2.10 起：
               _posix_c_source >= 200809l
           在 glibc 2.10 之前：
               _GNU_SOURCE

说明
       printf() 系列函数按照下面描述的格式产生输出。  函数 printf() 和
       函数 printf() 和 vprintf() 将输出写入标准输出流 stdout；fprintf( ) 和 vfprintf() 将输出写入指定的输出流；sprintf( )
       流；sprintf()、snprintf()、vsprintf() 和 vsnprintf() 将输出写入字符串 str。

       函数 dprintf() 与 fprintf() 的功能相同，但它的输出对象是文件描述符 fd，而不是 stdio
       流。

       函数 snprintf() 和 vsnprintf() 最多向 str 写入大小字节（包括结束符空字节（'\0'））。

       函数 vprintf()、vfprintf()、vdprintf()、vsprintf()、vsnprintf() 等同于函数 printf()、
       fprintf()、dprintf()、sprintf()、snprintf() 函数等价，不同的是调用它们时使用的是 va_list 而不是变量数。
       参数。  这些函数不调用 va_end 宏。  由于调用了 va_arg 宏，ap 的值在调用后未定义。
       值在调用后未定义。  参见 stdarg(3)。

       所有这些函数都在格式字符串的控制下写入输出，格式字符串指定了后续参数（或通过可变长度函数访问的参数）的格式。
       参数（或通过 stdarg(3) 的变长参数设施访问的参数）的输出转换方式。

       C99 和 POSIX.1-2001 规定，如果调用 sprintf()、snprintf()、vsprintf() 或 vsnprintf()
       会导致在重叠的对象之间进行复制（例如，如果目标字符串数组和提供的一个
       输入参数指向同一个缓冲区）。  请参阅注释。

   格式字符串的格式
       格式字符串是一个字符串，以其初始移位状态（如果有）开始和结束。  格式字符串由
       由零个或多个指令组成：普通字符（非 %），这些字符将原封不动地复制到输出流；以及
       转换规范，每个转换规范都会获取零个或多个后续参数。  每个转换规范
       都以字符 % 开始，并以转换规范结束。  中间可能有（按此顺序排列）
       零个或多个标志、可选的最小字段宽度、可选的精度和可选的长度修饰符。

       参数必须与转换指定符正确对应（类型提升后）。  默认情况下，参数
       将按给出的顺序使用，其中每个 "*"（见下文字段宽度和精度）和每个转换指定符都要求使用
       下一个参数（如果给出的参数数量不足，则会出错）。  也可以明确指定
       也可以在每个需要参数的地方明确指定使用哪个参数，方法是用"%m$"代替"%"，用 "*m$"代替 "*"、
       其中十进制整数 m 表示所需参数在参数列表中的位置，索引从 1 开始。
       因此

           printf("%*d", width, num)；

       和

           printf("%2$*1$d", width, num)；

       是等价的。  第二种样式允许重复引用同一参数。  C99 标准不包括
       样式，该样式来自《单一 UNIX 规范》。  如果使用"$"样式，则必须将其贯穿于
       但可以与"%%"格式混合使用、
       格式混合使用。  使用"$"指定的参数个数不得有间隙；例如，如果
       指定了参数 1 和 3，那么参数 2 也必须在格式字符串的某处指定。

       对于某些数字转换，会使用弧度字符（"小数点"）或千位分组字符。   实际使用的
       字符取决于本地语言的 LC_NUMERIC 部分。  (参见 setlocale(3)）。  POSIX 本地语言使用". "作为半角
       字符，没有分组字符。  因此

           printf("%'.2f", 1234567.89)；

       在 POSIX 本地语言中的结果是 "1234567.89"，在 nl_NL 本地语言中的结果是 "1234567,89"，在 da_DK 本地语言中的结果是 "1.234.567,89"。
       cale。

   标志字符
       字符 % 后跟 0 个或多个以下标志：

       # 值应转换为 "另一种形式"。  对于 o 转换，输出字符串的第一个字符
              的第一个字符变为 0（如果已经不是 0，则在前面加上 0）。  对于 x 和 X 转换，非零结果的字符串为
              字符串 "0x"（或 X 转换的 "0X"）。  对于 a、A、e、E、f、F、g 和 G 转换，结果
              将始终包含一个小数点，即使后面没有数字（通常情况下，只有在有数字的情况下，小数点才会出现在这些转换的结果中
              小数点只会出现在这些转换的结果中）。  对于 g 和 G 转换，尾数零不会从结果中删除。
              结果中的尾零。  对于其他转换，结果是未定义的。

       0 值应填充为零。  对于 d、i、o、u、x、X、a、A、e、E、f、F、g 和 G 转换，转换后的值在左侧填充 z。
              将在左侧填充 0 而不是空白。  如果 0 和 - 标志同时出现，0 标志将被忽略。  如果
              数字转换（d、i、o、u、x 和 X）时，0 标志将被忽略。   对于其他转换
              的行为未定义。

       - 转换后的数值将在字段边界上左对齐。  (默认为右对齐）。
              转换后的值将在右侧填充空白，而不是在左侧填充空白或 0。  如果同时给出 A
              如果同时给出这两个值，则 A

       ' ' （空格）有符号转换产生的正数（或空字符串）前应留出空白。

       + 符号（+ 或-）应始终放在有符号转换产生的数字之前。  默认情况下，符号
              仅用于负数。  如果同时使用 "+"和"-"，则 "+"取代空格。

       C99 标准中定义了上述五个标志字符。  单一 UNIX 规范》还规定了一个标志符
       字符。

       '对于十进制转换（i、d、u、f、F、g、G），如果本地信息显示有千位分组字符，输出将以千位分组字符分组。
              分组字符。  (参见 setlocale(3)）。  请注意，许多版本的 gcc(1) 无法解析此选项，并会发出警告。
              会发出警告。  (SUSv2 不包含 %'F，但 SUSv3 增加了它。）

       glibc 2.2 增加了一个标志字符。

       I 对于十进制整数转换（i、d、u），输出将使用本地语言的替代输出数字（如果有的话）。  例如
              例如，自 glibc 2.2.3 起，在波斯语 ("fa_IR")语言中将使用阿拉伯数字。

   字段宽度
       可选的十进制数字字符串（第一位非零），指定最小字段宽度。  如果转换值的字符数少于字段宽度
       如果转换值的字符数少于字段宽度，则会在左边（或右边，如果给定了左调整标志
       则在右边添加空格）。  可以写 "*"或 "*m$"（对于某个十进制整数 m）来代替十进制数字字符串，以指定
       字段宽度分别在下一个参数或第 m 个参数中给出，这些参数必须是 int 类型。  A
       负字段宽度被视为"-"标志，后跟一个正字段宽度。  在任何情况下，一个不存在的或较小的
       在任何情况下，字段宽度不存在或过小都不会导致字段被截断；如果转换的结果比字段宽度大，字段会被扩大以包含转换结果。
       如果转换结果大于字段宽度，字段将被扩展以包含转换结果。

   精度
       可选精度，形式为句号（'.'），后接可选的十进制数字字符串。  代替小数
       可以写 "*"或 "*m$"（对于某个十进制整数 m），以指定精度在下一个参数或第 m 个参数中给出。
       或第 m 个参数中，这些参数必须是 int 类型。  如果精确度仅以".
       则精度为零。  如果精度为负数，则视精度为省略值。  这给出了
       在 d、i、o、u、x 和 X 转换中出现的最小位数，在 a、A、e、E 转换中出现在弧度字符后的最小位数。
       的最小位数，a、A、e、E、f 和 F 转换的最大有效位数，g 和 G 转换的最大有效位数，或
       字符串中打印的最大字符数。

   长度修饰符
       这里的 "整数转换 "代表 d、i、o、u、x 或 X 转换。

       hh 下面的整数转换对应于有符号字符串或无符号字符串参数，或者下面的 n 转换对应于指向有符号字符串参数的指针。
              对应指向有符号 char 参数的指针。

       h 下面的整数转换对应 short 或无符号 short 参数，或下面的 n 转换对应指向有符号 char 参数的指针。
              对应于短参数指针。

       l（ell） 下面的整数转换对应长或无符号长参数，或下面的 n 转换对应短参数指针。
              对应长参数指针，或 c 转换对应 wint_t 参数，或
              后的 s 转换对应于指向 wchar_t 参数的指针。

       ll（ell-ell）。  后续整数转换对应 long long 或无符号 long long 参数，或后续 n 转换对应指向 wchar_t 参数的指针。
              n 转换对应 long long 参数指针。

       q ll 的同义词。  这是从 BSD 派生的一个非标准扩展，请避免在新代码中使用。

       L 在 a、A、e、E、f、F、g 或 G 转换之后，对应于一个长双参数。  (C99 允许使用 %LF，但 SUSv2 不允许。
              不允许）。

       j 下面的整数转换对应于 intmax_t 或 uintmax_t 参数，或者下面的 n 转换对应于
              对应于指向 intmax_t 参数的指针。

       z 下面的整数转换对应于一个 size_t 或 ssize_t 参数，或者下面的 n 次转换对应于一个 size_t 或 ssize_t 参数的指针。
              对应于指向 size_t 参数的指针。

       Z 是 z 的非标准同义词，早于 z 的出现。

       t 下面的整数转换对应于 ptrdiff_t 参数，或者下面的 n 转换对应于
              指向 ptrdiff_t 参数的指针。

       SUSv3 规定了上述所有内容，但明确指出为非标准扩展的修饰符除外。  SUSv2
       只指定了长度修饰符 h（在 hd、hi、ho、hx、hX、hn 中）和 l（在 ld、li、lo、lx、lX、ln、lc、ls 中）以及 L（在 Le、
       LE、Lf、Lg、LG）。

       作为一种非标准扩展，GNU 实现将 ll 和 L 视为同义词，例如，可以将 llg
       (作为符合标准的 Lg 的同义词）和 Ld（作为符合标准的 lld 的同义词）。  这种用法不
       可移植性。

   转换说明符
       指定转换类型的字符。  转换指定符及其含义如下：

       d, i int 参数转换为带符号的十进制符号。  精度（如果有）是指必须出现的最小数字个数。
              如果转换后的数值需要的位数较少，则在左边填充 0。   除错精度为 1。
              当打印 0 时，如果显式精度为 0，则输出为空。

       o、u、x、X
              将无符号 int 参数转换为无符号八进制（o）、无符号十进制（u）或无符号十六进制（x 和
              X）符号。  字母 abcdef 用于 x 转换；字母 ABCDEF 用于 X 转换。   精度
              精度（如果有）给出了必须出现的最小位数；如果转换后的数值需要更少的位数，则在转换后的位数上填充。
              如果转换后的数值需要更少的位数，则在左边填充 0。  默认精度为 1。
              时，输出为空。

       e, E 双参数按 [-]d.ddde±dd 样式舍入和转换，其中有一位数（如果参数为非零，则为非零）。
              如果参数为非零），小数点后的位数等于精度。
              如果精度为零，则不出现小数点字符。
              出现。  E 转换使用字母 E（而不是 e）来引入指数。  指数总是包含
              如果数值为零，则指数为 00。

       f, F 双参数四舍五入并转换为十进制符号，样式为 [-]ddd.ddd，其中小数点后的位数为[-]ddd.ddd。
              小数点后的数字等于指定的精度。  如果精度缺失，则
              如果精度明确为零，则不出现小数点字符。  如果出现小数点、
              小数点前至少出现一位数。

              (SUSv2 不了解 F，并表示可以使用字符串表示无穷大和 NaN。
              的字符串表示。   C99 标准规定用"[-]inf "或"[-]infinity "表示无穷大，用以 "nan "开头的字符串表示 NaN。
              在 F 转换的情况下，"[-]INF "或"[-]INFINITY "或 "NAN "开头的字符串表示 NaN。
              F）。

       g, G 双参数按 f 或 e（G 转换时为 F 或 E）样式转换。  精度指定
              有效位数。  如果精度缺失，则给出 6 位数；如果精度为零，则视为
              1.   如果转换后的指数小于-4 或大于等于精度，则使用样式 e。
              结果中的小数部分会去掉尾数零；只有在小数点后至少有一位数时，才会出现小数点。
              小数点后才会出现。

       a、A（C99；不在 SUSv2 中，但在 SUSv3 中增加） 对于转换，双参数将转换为十六进制符号
              (对于 A 转换，使用前缀 0X、字母 ABCDEF 和指数分隔符 P。
              使用指数分隔符 P。  小数点前有一位十六进制数，小数点后的位数等于精度。
              之后的位数等于精度。  如果存在以基数 2 为单位的精确表示，默认精度足以精确表示数值。
              否则，默认精度足以区分 double 类型的值。
              对于非规范化数值，小数点前的位数不指定，而对于规范化数值，小数点前的位数不为零但不指定。
              对于规范化数字，小数点前的数字不指定。  指数总是包含至少一位数字；如果数值为零，指数为 0。

       c 如果没有 l 修饰符，int 参数将转换为无符号字符，并写入结果字符。
              写入。  如果存在 l 修饰符，则 wint_t（宽字符）参数将通过调用 wcrtomb 函数转换为多字节序列。
              调用 wcrtomb(3) 函数，将 wint_t（宽字符）参数转换为多字节序列，转换状态从初始状态开始，然后写入生成的多
              字节字符串。

       s 如果没有 l 修饰符：const char * 参数将被视为字符类型数组的指针（字符串指针）。
              (字符串的指针）。   数组中的字符将被写入，直至（但不包括）一个终止的空字节
              ('\0')；如果指定了精度，写入的字符数不会超过指定的数目。  如果指定了精度，则
              如果没有指定精度，或者精度大于数组的大小，数组
              必须包含一个终止的空字节。

              如果出现 l 修饰符：const wchar_t * 参数将被视为指向宽字符数组的指针。
              数组的指针。  数组中的宽字符将被转换为多字节字符（每个字符都要调用 wcrtomb(3) 函数，转换状态从开始时的"...... "开始）。
              函数的调用，转换状态从第一个宽字符前的初始状态开始），直到并包括一个终止的空宽字符。
              结束的空宽字符。  由此产生的多字节字符被写入到（但不包括）空字节。
              最小空字节。  如果指定了精度，则写入的字节数不会多于指定的字节数，但不会写入部分多字节字符。
              但不会写入部分多字节字符。  请注意，精度决定写入的字节数，而不是宽字符数或屏幕位置。
              宽字符数或屏幕位置。  数组必须包含一个终止的空宽字符，除非给定了一个
              精度太小，以至于在数组结束前写入的字节数超过精度。
              达到。

       C（不在 C99 或 C11 中，但在 SUSv2、SUSv3 和 SUSv4 中）与 lc 同义。  不要使用。

       S（不在 C99 或 C11 中，但在 SUSv2、SUSv3 和 SUSv4 中）与 ls 同义。  请勿使用。

       p void * 指针参数以十六进制打印（如同 %#x 或 %#lx）。

       n 目前已写入的字符数将存储到相应参数指向的整数中。   该
              参数应为 int *，或其大小与（可选）提供的整数长度修饰符相匹配的变量。  不转换
              参数进行转换。  (仿生 C 语言库不支持该指定）。
              转换指定包含任何标志、字段宽度或精度，则行为未定义。

       m（Glibc 扩展；受 uClibc 和 musl 支持）打印 strerror(errno) 的输出。  不需要参数。

       % 会写入一个 '%'。  不转换参数。  完整的转换规范为"%%"。

返回值
       成功返回后，这些函数将返回打印的字符数（不包括用于结束输出字符串的空字节）。
       不包括用于结束字符串输出的空字节）。

       函数 snprintf() 和 vsnprintf() 不会写入超过大小的字节（包括结束空字节（'\0'））。
       如果输出因这一限制而被截断，那么返回值就是本应写入的字符数（不包括终止的空字节）。
       空字节）。  因此，返回值
       或更多意味着输出已被截断。  (另请参阅下面的注释）。

       如果遇到输出错误，则返回负值。

属性
       有关本节所用术语的解释，请参阅 attributes(7)。

       ┌────────────────────────┬───────────────┬────────────────┐
       接口 │ 属性 │ 值 │ ├┼┼┤
       ├────────────────────────┼───────────────┼────────────────┤
       │printf(), fprintf(), │ 线程安全 │ MT-Safe locale │
       │sprintf(), snprintf(), │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │
       │vprintf(), vfprintf(), │ │ │ │ │
       │vsprintf()、vsnprintf() │ │ │ │
       └────────────────────────┴───────────────┴────────────────┘

符合
       fprintf()、printf()、sprintf()、vprintf()、vfprintf()、vsprintf()：POSIX.1-2001, POSIX.1-2008, C89, C99.

       snprintf()、vsnprintf()：PSIX.1-2001、PSIX.1-2008、C99。

       dprintf() 和 vdprintf() 函数最初是 GNU 扩展，后来在 POSIX.1-2008 中被标准化。

       关于 snprintf() 的返回值，SUSv2 和 C99 相互矛盾：当调用 snprintf() 时，size=0，则
       SUSv2 规定了一个小于 1 的未指定返回值，而 C99 允许 str 在这种情况下为 NULL，并给出了返回值（一如既往
       返回值（一如既往）是在输出字符串足够大的情况下写入的字符数。
       足够大。  POSIX.1-2001 及以后版本将 snprintf() 的规范与 C99 保持一致。

       glibc 2.1 增加了长度修饰符 hh、j、t 和 z 以及转换字符 a 和 A。

       glibc 2.2 增加了具有 C99 语义的转换字符 F 和标志字符 I。

注释
       有些程序轻率地依赖于以下代码

           sprintf(buf, "%s some further text", buf)；

       这样的代码来向 buf 追加文本。  然而，标准明确指出，在调用 sprintf() 时，如果源缓冲区和目标缓冲区重叠，结果将是未定义的。
       在调用 sprintf()、snprintf()、vsprintf() 和 vsnprintf() 时，如果源缓冲区和目标缓冲区重叠，结果将是不确定的。  根据所使用的 gcc(1) 版本、
       和编译器选项的不同，上述调用不会产生预期的结果。

       函数 snprintf() 和 vsnprintf() 的 glibc 实现符合 C99 标准，也就是说，其行为如上文所述。
       的行为。  在 glibc 2.0.6 之前，当输出被截断时，它们会返回-1。

缺陷
       由于 sprintf() 和 vsprintf() 假设字符串任意长，因此调用者必须注意不要溢出实际的
       这一点通常无法保证。  需要注意的是，产生的字符串长度与本地有关，很难预测。
       难以预测。  请使用 snprintf() 和 vsnprintf() 代替（或 asprintf(3) 和 vasprintf(3)）。

       printf(foo); 这样的代码通常表明存在漏洞，因为 foo 可能包含一个 % 字符。  如果 foo 来自不信任的用户
       输入，则可能包含 %n，从而导致 printf() 调用写入内存，造成安全漏洞。

示例
       打印 Pi 到小数点后五位

           #include <math.h>
           #include <stdio.h>
           fprintf(stdout, "pi = %.5f\n", 4 * atan(1.0))；

       以 "星期日，7 月 3 日，10:02 "的形式打印日期和时间，其中星期和月份是字符串指针：

           #include <stdio.h>
           fprintf(stdout, "%s, %s %d, %.2d:%.2d\n"、
                   weekday, month, day, hour, min)；

       许多国家使用日-月-年顺序。  因此，国际化版本必须能够按格式指定的顺序打印参数
       格式指定的顺序打印参数：

           #include <stdio.h>
           fprintf(stdout, format、
                   weekday, month, day, hour, min)；

       其中，format 取决于本地语言，并可能改变参数。  值为

           "%1$s, %3$d.%2$s, %4$d:%5$.2d\n"

       可以得到 "Sonntag, 3. Juli, 10:02"。

       分配一个足够大的字符串并打印进去（代码在 glibc 2.0 和 glibc 2.1 中都正确）：

       #include <stdio.h>
       #包含 <stdlib.h>
       #包含 <stdarg.h>

       char *
       make_message(const char *fmt, ...)
       {
           int n = 0；
           size_t size = 0；
           char *p = NULL；
           va_list ap；

           /* 确定所需大小 */

           va_start(ap, fmt)；
           n = vsnprintf(p, size, fmt, ap)；
           va_end(ap)；

           如果（n < 0）
               返回 NULL；

           /* 多一个字节表示 "0" */

           size = (size_t) n + 1；
           p = malloc(size)；
           if (p == NULL)
               返回 NULL；

           va_start(ap, fmt)；
           n = vsnprintf(p, size, fmt, ap)；
           va_end(ap)；

           if (n < 0) {
               free(p)；
               返回 NULL；
           }

           return p；
       }

       如果在 2.0.6 之前的 glibc 版本中发生截断，则将作为错误处理，而不是优雅地处理。

另请参见
       printf(1), asprintf(3), puts(3), scanf(3), setlocale(3), strfromd(3), wcrtomb(3), wprintf(3), locale(5)

COLOPHON
       本页是 Linux man-pages 项目 5.10 版的一部分。  该项目介绍、有关报告
       本页的最新版本，请访问 https://www.kernel.org/doc/man-pages/。

gnu 2020-11-01 printf(3)
